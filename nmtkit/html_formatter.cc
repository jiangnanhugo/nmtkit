#include <nmtkit/html_formatter.h>

#include <algorithm>
#include <functional>
#include <regex>
#include <boost/format.hpp>
#include <nmtkit/exception.h>

using std::string;
using std::vector;

namespace {

// Excapes given text.
string escape(const string & text) {
  string result = std::regex_replace(text, std::regex(R"(&)"), "&amp;");
  result = std::regex_replace(result, std::regex(R"(<)"), "&lt;");
  result = std::regex_replace(result, std::regex(R"(>)"), "&gt;");
  return std::regex_replace(result, std::regex(R"(")"), "&quot;");
}

string js_escape(const string & text) {
  return std::regex_replace(text, std::regex(R"(")"), R"(\")");
}

// Computes background color of the attention matrix.
string attenBGColor(float prob) {
  const int col = std::min(255, std::max(0, static_cast<int>(256.0 * prob)));
  return (boost::format("#%02x%02x%02x") % col % col % col).str();
}

// Computes foreground color of the attention matrix.
string attenFGColor(float prob) {
  return ::attenBGColor(prob >= 0.5f ? 0.0f : prob + 0.5f);
}

// Retrieves the length of the longest path.
unsigned longestPathLength(const nmtkit::InferenceGraph::Node * node) {
  unsigned longest = 0;
  for (const auto next : node->next()) {
    unsigned len = ::longestPathLength(next);
    if (len > longest) {
      longest = len;
    }
  }
  return longest + 1;
}

// Retrieves the virtual height of the subgraph.
unsigned virtualHeight(const nmtkit::InferenceGraph::Node * node) {
  unsigned height = 0;
  for (const auto next : node->next()) {
    height += virtualHeight(next);
  }
  return std::max(height, 1u);
}

// Javascript utilities.

string stroke_color_fmt(unsigned r, unsigned g, unsigned b, float a) {
  return (boost::format(R"(
ctx.strokeStyle = 'rgba(%1%, %2%, %3%, %4%)';
)") % r % g % b % a).str();
}

string fill_color_fmt(unsigned r, unsigned g, unsigned b, float a) {
  return (boost::format(R"(
ctx.fillStyle = 'rgba(%1%, %2%, %3%, %4%)';
)") % r % g % b % a).str();
}

string rect_fmt(float x, float y, float w, float h) {
  return (boost::format(R"(
ctx.fillRect(%1%, %2%, %3%, %4%);
)") % x % y % w % h).str();
}

string circle_fmt(float x, float y, float r) {
  return (boost::format(R"(
ctx.beginPath();
ctx.arc(%1%, %2%, %3%, 0, 2 * Math.PI);
ctx.closePath();
ctx.fill();
)") % x % y % r).str();
}

string bezier_fmt(float x1, float y1, float x2, float y2) {
  const float xm = (x1 + x2) / 2.0f;
  return (boost::format(R"(
ctx.beginPath();
ctx.moveTo(%1%, %4%);
ctx.bezierCurveTo(%2%, %4%, %2%, %5%, %3%, %5%);
ctx.stroke();
)") % x1 % xm % x2 % y1 % y2).str();
}

string text_fmt(float x, float y, const string & text) {
  return (boost::format(R"(
ctx.fillText("%3%", %1%, %2%);
)") % x % y % js_escape(text)).str();
}

}  // namespace

namespace nmtkit {

HTMLFormatter::HTMLFormatter() : num_outputs_(0) {}

void HTMLFormatter::initialize(std::ostream * os) {
  *os << R"(
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<title>Translation Results</title>
<style type="text/css">
* {
  margin: 0;
  padding: 0;
  background: inherit;
  color: #000;
  font-size: 16px;
  font-weight: normal;
}
section {
  margin: 12px;
  padding: 12px;
  background: #def;
  border: solid 1px #445;
}
h1 {
  margin: 10x;
  padding: 10px;
  font-size: 32px;
}
h2 {
  margin: 0;
  padding: 8px;
  border-bottom: solid 2px #556;
  font-size: 24px;
}
h3 {
  margin: 16px 0 8px;
  padding: 6px;
  border-bottom: dotted 1px #889;
  font-size: 18px;
}
p {
  margin: 4px 0;
}
table {
  border-collapse: collapse;
}
th {
  padding: 8px;
  border: none;
  text-align: center;
  vertical-align: middle;
}
td {
  padding: 8px;
  border: solid 1px #000;
  text-align: center;
  vertical-align: middle;
}
canvas {
  background: transparent;
  border: solid 1px #89a;
}
.word {
  display: inline-block;
  margin: 2px 3px;
  padding: 3px 6px;
  line-height: 1.2em;
  background: #ddd;
  border: solid 1px #666;
  border-radius: 4px;
}
</style>
</head>
<body>
<header><h1>Translation Results</h1></header>
<article>
)";
}

void HTMLFormatter::finalize(std::ostream * os) {
  *os << R"(
</article>
<footer><p>This document is generated by <a href="https://github.com/odashi/nmtkit">NMTKit</a>.</p></footer>
</body>
</html>
)";
}

void HTMLFormatter::write(
    const string & source_line,
    const string & ref_line,
    const InferenceGraph & ig,
    const Vocabulary & source_vocab,
    const Vocabulary & target_vocab,
    std::ostream * os) {
  const unsigned bos_id = target_vocab.getID("<s>");
  const unsigned eos_id = target_vocab.getID("</s>");

  // Note: this formatter outputs only the one-best result.
  auto nodes = ig.findOneBestPath(bos_id, eos_id);

  // Retrieves actual input words.
  vector<string> actual_source_words;
  for (const unsigned id : source_vocab.convertToIDs(source_line)) {
    actual_source_words.emplace_back(source_vocab.getWord(id));
  }

  // Retrieves output word IDs.
  vector<unsigned> target_word_ids;
  for (unsigned i = 1; i < nodes.size() - 1; ++i) {
    target_word_ids.emplace_back(nodes[i]->label().word_id);
  }

  // Outputs HTML.
  *os << "<section>\n";
  *os << "<h2>Sentence " << (num_outputs_ + 1) << "</h2>\n";

  *os << "<h3>Raw input line</h3>\n";
  *os << "<p><span class=\"word\">"
      << ::escape(source_line)
      << "</span></p>\n";

  *os << "<h3>Actual input words</h3>\n";
  *os << "<p>";
  for (const string & w : actual_source_words) {
    *os << "<span class=\"word\">" << ::escape(w) << "</span>";
  }
  *os << "</p>\n";

  *os << "<h3>Output words</h3>\n";
  *os << "<p>";
  for (const unsigned word_id : target_word_ids) {
    *os << "<span class=\"word\">"
        << ::escape(target_vocab.getWord(word_id))
        << "</span>";
  }
  *os << "</p>\n";

  *os << "<h3>Restored output line</h3>\n";
  *os << "<p><span class=\"word\">"
      << ::escape(target_vocab.convertToSentence(target_word_ids))
      << "</span></p>\n";

  if (ref_line != "") {
    *os << "<h3>Reference line</h3>\n";
    *os << "<p><span class=\"word\">"
        << ::escape(ref_line)
        << "</span></p>\n";
  }

  *os << "<h3>Word probabilities</h3>\n";
  *os << "<table>\n";
  *os << "<tr><th>Word</th><th>log P(word)</th><th>Accumulated log P(word)</th></tr>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><td>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</td><td>"
        << label.word_log_prob
        << "</td><td>"
        << label.accum_log_prob
        << "</td></tr>\n";
  }
  *os << "</table>\n";

  *os << "<h3>Attention</h3>\n";
  *os << "<table>\n";
  *os << "<tr><th></th><th>&lt;s&gt;</th>";
  for (const string & w : actual_source_words) {
    *os << "<th>" << ::escape(w) << "</th>";
  }
  *os << "<th>&lt;/s&gt;</th></tr>\n";
  for (unsigned i = 1; i < nodes.size(); ++i) {
    const nmtkit::InferenceGraph::Label & label = nodes[i]->label();
    *os << "<tr><th>"
        << ::escape(target_vocab.getWord(label.word_id))
        << "</th>";
    for (const float atten : label.atten_probs) {
      *os << "<td style=\"background: "
          << attenBGColor(atten)
          << "; color: "
          << attenFGColor(atten)
          << ";\">"
          << (boost::format("%.2f") % atten)
          << "</td>";
    }
    *os << "</tr>\n";
  }
  *os << "</table>";

  const unsigned PADDING = 32;
  const unsigned PATH_W = 60;
  const unsigned PATH_H = 32;
  const unsigned lpl = ::longestPathLength(nodes[0]);
  const unsigned width =
      2 * PADDING + PATH_W * (lpl - 1);
  const unsigned height =
      2 * PADDING + PATH_H * (::virtualHeight(nodes[0]) - 1);
  *os << (boost::format(R"(
<h3>Inference graph</h3>
<canvas id="canvas-%1%" width="%2%" height="%3%"></canvas>
<script type="text/javascript">
ctx = document.getElementById("canvas-%1%").getContext("2d");
ctx.font = "14px Sans-Serif";
ctx.textAlign = "center";
)") % (num_outputs_ + 1) % width % height);

  // Background
  *os << ::fill_color_fmt(255, 255, 255, 1.0);
  *os << ::rect_fmt(0, 0, width, height);

  std::function<unsigned(float, float, const InferenceGraph::Node *)>
      write_subgraph =
      [&](float x, float y, const InferenceGraph::Node * node) {
    unsigned vh = 0;
    for (const auto next : node->next()) {
      const float nx = x + PATH_W;
      const float ny = y + PATH_H * vh;
      if (find(nodes.begin(), nodes.end(), next) != nodes.end()) {
        *os << ::stroke_color_fmt(230, 20, 40, 1.0);
      } else {
        *os << ::stroke_color_fmt(20, 60, 180, 0.4);
      }
      *os << ::bezier_fmt(x, y, nx, ny);

      vh += write_subgraph(nx, ny, next);
    }

    const string word_str = target_vocab.getWord(node->label().word_id);
    const unsigned y2 = y - 9;
    if (find(nodes.begin(), nodes.end(), node) != nodes.end()) {
      *os << ::fill_color_fmt(230, 20, 40, 1.0);
      *os << ::circle_fmt(x, y, 4);
      *os << ::fill_color_fmt(150, 10, 20, 1.0);
      *os << ::text_fmt(x, y2, word_str);
    } else {
      *os << ::fill_color_fmt(20, 40, 100, 1.0);
      *os << ::circle_fmt(x, y, 4);
      *os << ::fill_color_fmt(0, 0, 0, 1.0);
      *os << ::text_fmt(x, y2, word_str);
    }

    return std::max(vh, 1u);
  };

  write_subgraph(PADDING, PADDING, nodes[0]);

  *os << "</script>\n";

  *os << "</section>\n";

  ++num_outputs_;
}

}  // namespace nmtkit
